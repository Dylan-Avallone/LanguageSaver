<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <h2 class="mb-4">
    Practice: {{ exercise.title }} (<span id="modeDisplay"></span>)
  </h2>
  

  <!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <style>
    body {
      background-color: #f4f4f9;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .sentence {
      font-size: 2.5rem;
      font-weight: bold;
      color: rgb(80, 79, 79);
      text-align: center;
      margin-bottom: 30px;
    }
    .buttons {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
    }
    .feedback {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .feedback.correct {
      color: #28a745; /* Green */
    }
    .feedback.incorrect {
      color: #dc3545; /* Red */
    }
    /* Styling for highlighted (toggled) buttons */
    .highlighted {
      background-color: #007bff !important;
      color: white !important;
      border: 2px solid #0056b3 !important;
    }
    /* Centering buttons */
    .button-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
  </style>
  
  <script>
       // Always enable Dark Mode on page load
       localStorage.setItem("dark-mode", "enabled");
    document.addEventListener("DOMContentLoaded", function () {
        document.body.classList.add("dark-mode");
    });
 const categories = JSON.parse('{{ categories|safe }}'); // ‚úÖ Convert Flask JSON to JavaScript object
 window.conjugations = JSON.parse('{{ conjugations|safe }}'); // ‚úÖ Store conjugations globally
 console.log("üìå Conjugations Loaded:", window.conjugations);


 async function fetchSentence() {
    try {
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get("mode") || "reasoning";
        const tenses = JSON.parse(sessionStorage.getItem("selectedTenses") || "[]");

        console.log("üìå Fetching a new sentence for mode:", mode);
        console.log("üìå Tenses for conjugation:", tenses);

        const exerciseKey = new URLSearchParams(window.location.search).get("exercise") || "ser_estar";
        const response = await fetch(`/api/${exerciseKey}?mode=${mode}&tenses=${encodeURIComponent(JSON.stringify(tenses))}`);


        const data = await response.json();
        console.log("‚úÖ Received data:", data);

        // ‚úÖ Ensure elements exist before updating them
        const sentenceEl = document.getElementById("sentence");
        const correctEl = document.getElementById("correct");
        const correctCategoryEl = document.getElementById("correctCategory");
        const correctTenseEl = document.getElementById("correctTense");
        const feedbackEl = document.getElementById("feedback");
        const categoryButtons = document.getElementById("categoryButtons");
        const tenseButtonsContainer = document.getElementById("tenseButtonsContainer");
        const subjectPronounEl = document.getElementById("subjectPronoun"); // ‚úÖ New: Store subject pronoun
        const verbFormEl = document.getElementById("verbForm");


        if (!sentenceEl || !correctEl || !feedbackEl|| !subjectPronounEl) {
            console.error("‚ùå ERROR: One or more required elements are missing in the DOM.");
            return;
        }

        // ‚úÖ Update the DOM with the new sentence
        sentenceEl.innerText = data.sentence;
        correctEl.value = data.correct ? data.correct.trim().toLowerCase() : ""; // Prevents undefined values

        // ‚úÖ Store correct category if in reasoning mode
        if (mode === "reasoning" && correctCategoryEl) {
            if (data.category) {
                correctCategoryEl.value = data.category.trim(); // ‚úÖ Store category properly
            } else {
                console.error("‚ùå ERROR: Missing category from AI response.");
                correctCategoryEl.value = ""; // ‚úÖ Prevent undefined issues
            }
        }

        // ‚úÖ Store correct tense if in conjugation mode
        else if (mode === "conjugation") {
            // ‚úÖ Store correct tense if in conjugation mode
            if (correctTenseEl) {
                correctTenseEl.value = data.tense ? data.tense.trim() : "";
            }
              // ‚úÖ Check if `verb_form` exists and store it
        if (data.verb_form) {
            verbFormEl.value = data.verb_form.trim();
            console.log("‚úÖ Stored verb form:", `"${data.verb_form.trim()}"`);
        } else {
            console.error("‚ùå ERROR: AI response is missing `verb_form`!");
            verbFormEl.value = "";  // Avoid storing undefined
        }  
            // ‚úÖ Store subject pronoun for correct verb form retrieval (ONLY in conjugation mode)
            if (subjectPronounEl) {
                if (data.subject_pronoun) {
                    subjectPronounEl.value = data.subject_pronoun.trim();
                    console.log(`üìå Stored Subject Pronoun: "${data.subject_pronoun}"`);
                } else {
                    console.error("‚ùå ERROR: Missing subject pronoun from AI response.");
                    subjectPronounEl.value = "";
                }
            }
        }

        feedbackEl.innerText = ""; // Clear feedback

        // ‚úÖ Hide buttons when fetching a new sentence
        if (categoryButtons) {
            categoryButtons.style.display = "none"; // Hide category buttons on sentence fetch
        }

        if (tenseButtonsContainer) {
            tenseButtonsContainer.style.display = "none"; // Hide tense buttons on sentence fetch
        }
        if (conjugationButtonsContainer) {
            conjugationButtonsContainer.style.display = "none"; // Hide conjugation buttons on sentence fetch
        }

    } catch (error) {
        console.error("‚ùå Error fetching sentence:", error);
    }
}

async function checkAnswer(answer) {
    const correct = document.getElementById("correct").value.trim().toLowerCase();
    const mode = new URLSearchParams(window.location.search).get("mode") || "reasoning";
    const exerciseKey = new URLSearchParams(window.location.search).get("exercise") || "ser_estar";
    const categoryButtons = document.getElementById("categoryButtons");
    const tenseButtonsContainer = document.getElementById("tenseButtonsContainer"); 
    const feedbackEl = document.getElementById("feedback");

    console.log("üîç Stored correct answer:", correct);
    console.log("üîç User clicked answer:", answer.trim().toLowerCase());
    console.log("üìå Current Mode:", mode);
    console.log("üìå Selected Exercise:", exerciseKey);

    if (!categoryButtons || !tenseButtonsContainer) {
        console.error("‚ùå ERROR: `categoryButtons` or `tenseButtonsContainer` div not found!");
        return;
    }

    if (answer.trim().toLowerCase() === correct) {  
        console.log("‚úÖ Correct answer chosen:", answer.trim().toLowerCase());

        if (mode === "reasoning") {
            console.log("üîπ Reasoning Mode: Showing category buttons.");
            categoryButtons.innerHTML = ""; // Clear existing buttons

            let isPrepositionExercise = exerciseKey === "por_para";
            let categoriesList = isPrepositionExercise
                ? categories.preposition_exercises[exerciseKey][correct]
                : categories.verb_exercises[exerciseKey][correct];

            if (categoriesList) {
                const colors = ["c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10"];
                const darkModeColors = ["darkmode-c1", "darkmode-c2", "darkmode-c3", "darkmode-c4", "darkmode-c5",
                                        "darkmode-c6", "darkmode-c7", "darkmode-c8", "darkmode-c9", "darkmode-c10"];
                
                let assignedColors = {}; // Ensure consistent colors for the same category

                const isDarkMode = document.body.classList.contains("dark-mode");

                categoriesList.forEach((category, index) => {
                    const button = document.createElement("button");

                    if (!assignedColors[category]) {
                        assignedColors[category] = isDarkMode ? darkModeColors[index % darkModeColors.length] : colors[index % colors.length];
                    }

                    button.classList.add("btn", "category-button", "m-2", assignedColors[category]);
                    button.innerText = category;
                    button.onclick = () => checkCategory(category);
                    categoryButtons.appendChild(button);
                });

                categoryButtons.style.display = "block"; 
            } else {
                console.error(`‚ùå ERROR: Categories for ${exerciseKey} are missing.`);
                return;
            }

            feedbackEl.innerText = "‚úÖ Correct! Now select the category.";
            feedbackEl.className = "feedback correct";

        } else if (mode === "conjugation") {
            console.log("üîπ Conjugation Mode: Showing tense selection.");
            tenseButtonsContainer.innerHTML = ""; // Clear previous tense buttons

            const selectedTenses = JSON.parse(sessionStorage.getItem("selectedTenses") || "[]");
            console.log("üìå Selected Tenses:", selectedTenses);

            if (selectedTenses.length === 0) {
                console.error("‚ùå ERROR: No tenses selected.");
                return;
            }

            const colors = ["c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10"];
            const darkModeColors = ["darkmode-c1", "darkmode-c2", "darkmode-c3", "darkmode-c4", "darkmode-c5",
                                    "darkmode-c6", "darkmode-c7", "darkmode-c8", "darkmode-c9", "darkmode-c10"];
            
            let assignedColors = {}; // Ensure each tense gets the same color

            const isDarkMode = document.body.classList.contains("dark-mode");

            selectedTenses.forEach((tense, index) => {
                const button = document.createElement("button");

                if (!assignedColors[tense]) {
                    assignedColors[tense] = isDarkMode ? darkModeColors[index % darkModeColors.length] : colors[index % colors.length];
                }

                button.classList.add("btn", "tense-button", "m-2", assignedColors[tense]);
                button.innerText = tense;
                button.onclick = () => checkTense(tense);
                tenseButtonsContainer.appendChild(button);
            });

            tenseButtonsContainer.style.display = "block"; // Show the tense buttons

            feedbackEl.innerText = "‚úÖ Correct! Now select the correct tense.";
            feedbackEl.className = "feedback correct";
        }
    } else {
        console.log("‚ùå Incorrect answer detected! Retrying...");
        console.log("‚ùå Expected:", `"${correct}"`);
        console.log("‚ùå User Input:", `"${answer.trim().toLowerCase()}"`);

        categoryButtons.style.display = "none"; 
        tenseButtonsContainer.style.display = "none"; 
        feedbackEl.innerText = "‚ùå Incorrect!";
        feedbackEl.className = "feedback incorrect";

        setTimeout(() => {
            fetchSentence();
        }, 1000);
    }
}












function checkCategory(category) {
    const correctCategory = document.getElementById("correctCategory").value.trim(); // ‚úÖ Ensure no spaces

    console.log("üîç User selected category:", category);
    console.log("üìå Correct category from AI:", correctCategory);

    if (category === correctCategory) {
        console.log("üéâ Correct category selected!");

        document.getElementById("feedback").innerText = "‚úÖ Correct!";
        document.getElementById("feedback").className = "feedback correct";

        setTimeout(fetchSentence, 1000);
    } else {
        console.log("‚ùå Incorrect category! Try again.");

        document.getElementById("feedback").innerText = "‚ùå Incorrect! Try again.";
        document.getElementById("feedback").className = "feedback incorrect";
    }
}



function checkTense(selectedTense) {
    const correctTenseEl = document.getElementById("correctTense");
    if (!correctTenseEl) {
        console.error("‚ùå ERROR: `correctTense` hidden input is missing.");
        return;
    }

    const correctTense = correctTenseEl.value.trim().toLowerCase().replace(/_/g, " ");
    const userTense = selectedTense.trim().toLowerCase().replace(/_/g, " ");

    console.log("‚úÖ User selected tense:", `"${userTense}"`);
    console.log("üìå Correct tense from AI:", `"${correctTense}"`);

    if (userTense === correctTense) {
        console.log("üéâ Correct tense selected!");

        document.getElementById("feedback").innerText = "‚úÖ Correct! Now select the correct verb form.";
        document.getElementById("feedback").className = "feedback correct";

        // ‚úÖ Retrieve the correct verb from the stored input
        const correctVerb = document.getElementById("correct").value.trim().toLowerCase();

         // ‚úÖ Store subject pronoun globally
         window.subjectPronoun = document.getElementById("subjectPronoun").value.trim();
        console.log("üìå Stored Subject Pronoun:", window.subjectPronoun);

        // ‚úÖ Call function to generate conjugation buttons
        generateConjugationButtons(correctVerb);

    } else {
        console.log("‚ùå Incorrect tense! Try again.");
        document.getElementById("feedback").innerText = "‚ùå Incorrect! Try again.";
        document.getElementById("feedback").className = "feedback incorrect";
    }
}





function generateTenseButtons(tenses) {
    const tenseButtonsContainer = document.getElementById("tenseButtons");
    if (!tenseButtonsContainer) {
        console.error("‚ùå ERROR: Tense buttons container is missing.");
        return;
    }

    tenseButtonsContainer.innerHTML = ""; // ‚úÖ Clear previous buttons

    if (!tenses || tenses.length === 0) {
        tenseButtonsContainer.innerHTML = "<p>No tenses selected.</p>";
        return;
    }

    console.log("üìå Generating Tense Buttons:", tenses);

    tenses.forEach(tense => {
        const button = document.createElement("button");
        button.classList.add("btn", "btn-outline-primary", "m-2");
        button.innerText = tense;
        button.onclick = () => checkTense(tense);
        tenseButtonsContainer.appendChild(button);
    });

    console.log("‚úÖ Generated tense buttons:", tenses);
}

function generateConjugationButtons(correctVerb) {
    const conjugationButtonsContainer = document.getElementById("conjugationButtonsContainer");
    if (!conjugationButtonsContainer) {
        console.error("‚ùå ERROR: `conjugationButtonsContainer` div not found.");
        return;
    }

    conjugationButtonsContainer.innerHTML = ""; // ‚úÖ Clear previous buttons

    const selectedTenses = JSON.parse(sessionStorage.getItem("selectedTenses") || "[]");
    console.log("üìå Selected Tenses for Buttons:", selectedTenses);

    if (selectedTenses.length === 0) {
        console.error("‚ùå ERROR: No tenses selected.");
        return;
    }

    if (!window.conjugations || !window.conjugations[correctVerb]) {
        console.error(`‚ùå ERROR: No conjugations found for verb '${correctVerb}'.`);
        return;
    }

    if (!window.subjectPronoun) {
        console.error("‚ùå ERROR: Subject pronoun is missing!");
        return;
    }

    // ‚úÖ Subject Pronoun Map for Indexing into Conjugation Arrays
    const subjectMap = {
        "yo": 0, "t√∫": 1, "usted": 2, "√©l": 2, "ella": 2, 
        "nosotros": 3, "nosotras": 3, "vosotros": 4, "vosotras": 4, 
        "ustedes": 5, "ellos": 5, "ellas": 5
    };

    const subjectPronoun = window.subjectPronoun.toLowerCase();
    const subjectIndex = subjectMap[subjectPronoun];

    if (subjectIndex === undefined) {
        console.error(`‚ùå ERROR: Subject pronoun '${subjectPronoun}' not recognized.`);
        return;
    }

    console.log(`üìå Subject Pronoun: "${subjectPronoun}" ‚Üí Index: ${subjectIndex}`);

    const colors = ["c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10"];
    const darkModeColors = ["darkmode-c1", "darkmode-c2", "darkmode-c3", "darkmode-c4", "darkmode-c5",
                            "darkmode-c6", "darkmode-c7", "darkmode-c8", "darkmode-c9", "darkmode-c10"];
    const isDarkMode = document.body.classList.contains("dark-mode");

    let buttonData = [];

    // ‚úÖ Extract conjugations & store them with associated colors
    selectedTenses.forEach((tense, index) => {
        const formattedTense = tense.toLowerCase().replace(/\s/g, "_");

        if (!window.conjugations[correctVerb][formattedTense]) {
            console.warn(`‚ö† Warning: No conjugations found for '${correctVerb}' in '${formattedTense}'. Skipping...`);
            return;
        }

        const verbForm = window.conjugations[correctVerb][formattedTense][subjectIndex];

        if (!verbForm) {
            console.warn(`‚ö† Warning: No conjugation found at index ${subjectIndex} for '${formattedTense}'. Skipping...`);
            return;
        }

        const randomColor = isDarkMode
            ? darkModeColors[Math.floor(Math.random() * darkModeColors.length)]
            : colors[Math.floor(Math.random() * colors.length)];

        buttonData.push({ verbForm, color: randomColor });
    });

    // ‚úÖ Shuffle the conjugation buttons so they are randomized
    buttonData = buttonData.sort(() => Math.random() - 0.5);

    // ‚úÖ Create buttons & append them
    buttonData.forEach(({ verbForm, color }) => {
        const button = document.createElement("button");
        button.classList.add("btn", "conjugation-button", "m-2", color);
        button.innerText = verbForm;
        button.onclick = () => checkConjugation(verbForm);
        conjugationButtonsContainer.appendChild(button);
    });

    conjugationButtonsContainer.style.display = "block"; // ‚úÖ Show the buttons
    console.log("‚úÖ Conjugation buttons generated successfully!");
}





function checkConjugation(selectedConjugation) {
    const correctVerbForm = document.getElementById("verbForm").value.trim().toLowerCase();
    
    console.log("‚úÖ User selected conjugation:", `"${selectedConjugation}"`);
    console.log("üìå Correct conjugation from AI:", `"${correctVerbForm}"`);

    if (selectedConjugation.trim().toLowerCase() === correctVerbForm) {
        console.log("üéâ Correct conjugation selected!");
        document.getElementById("feedback").innerText = "‚úÖ Correct!";
        document.getElementById("feedback").className = "feedback correct";
        
        setTimeout(fetchSentence, 1000);
    } else {
        console.log("‚ùå Incorrect conjugation! Try again.");
        document.getElementById("feedback").innerText = "‚ùå Incorrect! Try again.";
        document.getElementById("feedback").className = "feedback incorrect";
    }
}








  </script>
</head>
<body>
  <div class="text-center mt-4">
    <a href="/" class="bottom-right-button">Back to Exercise Selection</a>
  </div>

    <div id="sentence" class="darkmode-sentence">Loading...</div>
    <input type="hidden" id="correct" />
<input type="hidden" id="correctCategory" />
<input type="hidden" id="correctTense" /> 
<input type="hidden" id="subjectPronoun" />
<input type="hidden" id="verbForm" />



    <!-- Verb1/Verb2 Answer buttons (Used in BOTH Reasoning & Conjugation) -->
    <div id="verbButtons">
      <h3 class = "dark-mode h3 " style="position: relative; top: 16px;">Select the Correct Answer:</h3>
      <div class="buttons">
        {% if exercise.verbs %}
          {% for verb in exercise.verbs %}
            <button class="btn btn-primary btn-lg"  onclick="checkAnswer('{{ verb }}')" style="position: relative; top: 16px;" >{{ verb.capitalize() }}</button>
          {% endfor %}
          <!--If its a perposition exercise, output preposition buttons-->
        {% elif exercise.prepositions %}
          {% for preposition in exercise.prepositions %}
            <button class="btn btn-primary btn-lg" onclick="checkAnswer('{{ preposition }}')" style="position: relative; top: 16px;">{{ preposition.capitalize() }}</button>
          {% endfor %}
        {% endif %}
      </div>
    </div>

<!-- Category Buttons (Only for Reasoning Mode) -->
<div id="categoryButtons" style="display: none;">
  <h3>Select the Category:</h3>
  <div class="button-group mt-3">
    {% for category in exercise.definitions.keys() %}
      <button class="btn category-button" data-category="{{ category }}" onclick="checkCategory('{{ category }}')">
        {{ category }}
      </button>
    {% endfor %}
  </div>
</div>



<!-- Tense Selection (Only for Conjugation Mode) -->
<div id="tenseButtonsContainer" style="display: none;">
  <h3>Select the Correct Tense:</h3>
  <div id="tenseButtons" class="button-group mt-3"></div>
</div>

    <div id="feedback" class="feedback"></div>
  </div>

 <!-- Conjugation Selection (Appears after selecting the correct tense) -->
<div id="conjugationButtonsContainer" style="display: none;">
  <h3>Select the Correct Conjugation:</h3>
  <div class="button-group mt-3"></div>
</div>


  <script>
document.addEventListener("DOMContentLoaded", function () {
    const urlParams = new URLSearchParams(window.location.search);
    const mode = urlParams.get("mode") || "reasoning"; // ‚úÖ Declare mode here before using it

    console.log("üìå Practice Mode:", mode); // ‚úÖ No more ReferenceError!

    let selectedTenses = [];
    if (mode === "conjugation") {
        selectedTenses = JSON.parse(sessionStorage.getItem("selectedTenses") || "[]");
        console.log("üìå Selected Tenses in Practice Page:", selectedTenses);
    }

    // ‚úÖ Ensure mode display exists before modifying
    const modeDisplay = document.getElementById("modeDisplay");
    if (modeDisplay) {
        modeDisplay.innerText = mode;
    } else {
        console.error("‚ùå ERROR: modeDisplay element is missing.");
    }

    // ‚úÖ Ensure tense display exists before modifying
    const tenseDisplay = document.getElementById("tenseDisplay");
    if (tenseDisplay) {
        if (selectedTenses.length > 0) {
            tenseDisplay.innerText = "Selected Tenses: " + selectedTenses.join(", ");
        } 
    } else {
        console.error("‚ùå ERROR: tenseDisplay element is missing.");
    }

    // ‚úÖ Generate Tense Buttons (Only for Conjugation Mode)
    if (mode === "conjugation") {
        generateTenseButtons(selectedTenses);
    }


   
    // ‚úÖ Fetch a new sentence after ensuring everything is set
    fetchSentence();
});


</script>

<div class="container">
    <h2>Practice Mode: <span id="modeDisplay">{{ mode }}</span></h2>
    <p id="tenseDisplay"></p>
</div>

</body>
</html>
